홍금락선생님 요구사항
테이블 연관관계
ui (어떻게 동작되는지 1구간정도)
기능 1~2개 (back + front 나눠서)
디테일 1~2개 정도
디자인패턴
mvc패턴 +util  
폴더개수 권장은 3개로 사용
테이블에 관련된 arraylist, set 등 이유

백
api
rest
토큰/OAuth2
JWT/Refresh Token

프론트
SPA
react
vite
jsx


백
1. mpa/api
pc통신시절에는 화면의 종류가 적기에 mpa방식을 사용했으나 스마트폰의 보급으로인해 화면비율이 엄청나게 다양해져 서버에서 모든 비율에 대한 처리를 하면 서버에 부담이 커지기에 서버에선 내용만 보내주고 프론트에서 화면을 구성하는 방식인 api방식을 사용하게됨 
2. rest/GraphQL/gRPC
rest는 가장 표준적이고 단순하며 추후설명할 리액트와의 연계성이 뛰어남
3. 세션 / 토큰 / OAuth2
OAuth2는 카카오 api를 사용하기위해 강제로 필요하기에 넘기고
세션은 단순하지만 상태를 저장해 직접관리해야되기에 확장성에 불리하다.
그에비해 토큰방식은 저장소없이 토큰자체만 검증하면되는 무상태 방식이며 확장성이 좋다.
4. JWT/Opaque Token/Refresh Token
 {질문대비용 : 오페이크 토큰은 랜덤문자열로서 보안은 좋지만 세션과 비슷하게 서버상태관리가 필요하기에 확장성에 약하다.} 
JWT (JSON Web Token) 토큰자체에 사용자 정보와 서명이 들어있음 api서버 구조와 호환이 좋으며 무상태방식으로 확장성에 용의하다. 다만 탈취위험이 크다는 단점이 있는데 이것을 Refresh Token을 추가하여 일정시간이 지날때마다 토큰을 초기화시켜주는 방식으로 최대한 방어하였다.



프론트
1. MPA/SPA
MPA 방식은 JSP나 XML 기반 템플릿을 사용해 화면을 구성했는데, 이는 설정이 복잡하고 프론트와 백엔드 코드가 뒤섞여 협업과 유지보수에 불리했습니다. 또한 서버가 모든 화면을 처리해야 하므로 서버 부하가 크게 걸리는 문제도 있었습니다. 반면 SPA 방식은 다양한 기기에 유연하게 대응할 수 있고, 앱처럼 부드러운 화면 전환과 높은 확장성을 제공하기 때문에 결국 SPA 방식을 선택하게 되었습니다
2. react, vue, angular 
3. vite, next.js
4. js, jsx, ts, tsx


폴더구조
1. 기능별 구조
2. 카멜표기법

ERD 스키마구조 (테이블 관계도) 설명 

기능
회원가입/로그인/마이페이지/관리자페이지
게시판
gym map(혁준씨 메인기능)

* 기능소개하면서 디테일 + 코드상 문제있었던거 각각 1개씩 정도 설명필요

현재 상황은, 로그인되지 않았거나 차단(banned)된 사용자가 로그인 시도를 할 경우, 이를 거부해야 하는 케이스입니다.

단순히 프론트단에서 차단 처리를 하는 건 보안상 문제가 있기 때문에, 이 책임은 **백엔드(Spring Security)**에서 처리하도록 했습니다.

그런데 로그인 실패 시 작동하는 LoginFailureHandler에서는 로그인 실패 응답을 JSON 형식으로 내려주기 위해 Gson을 사용하고 있었는데,
Gson은 LocalDateTime 타입을 기본적으로 처리하지 못해서 예외가 발생했습니다.

그래서 해결 방법으로, 로그인 실패 처리 부분(LoginFailureHandler)에서만 Jackson(ObjectMapper)을 사용하도록 바꿨고,
그 결과 LocalDateTime도 문제없이 직렬화되면서 JSON 응답을 안정적으로 내려줄 수 있게 되었습니다.


=============================================================
문제는 Redux Toolkit의 직렬화 과정에서 커스텀 객체 속성들이 손실되는 것이었습니다.

문제 분석:
CustomAuthenticationProvider에서 BannedMemberException 정상 발생
APILoginFailHandler에서 403 상태와 밴 정보 정상 응답
Jackson으로 LocalDateTime 직렬화 문제도 해결
프론트엔드 API 계층: 정상 작동 ✅

memberApi.jsx에서 403 에러 감지
BannedMemberException 생성하여 banInfo, isBannedMember 속성 추가
문제 지점: Redux Toolkit의 createAsyncThunk ❌

Redux Toolkit은 에러 객체를 직렬화할 때 표준 Error 속성만 유지
커스텀 속성 (banInfo, isBannedMember)은 손실됨
해결 방법:
조건을 단순화해서 error.message === "MEMBER_BANNED"만으로 밴된 회원을 식별하도록 수정했습니다:

// 이전 (작동 안 함)
if (error.isBannedMember || (error.message === "MEMBER_BANNED" && error.banInfo))

// 수정 후 (작동함!)
if (error.message === "MEMBER_BANNED")

그리고 banInfo가 없을 때는 기본값을 제공하여 모달이 열리도록 했습니다.

교훈:
Redux Toolkit을 사용할 때는 에러 객체의 커스텀 속성이 직렬화 과정에서 손실될 수 있다는 점을 항상 염두에 두어야 합니다!


================================================================

🔐 통일된 보안 설정 구조
1. JWTCheckFilter (1차 필터링)
JWT 토큰 검증 및 인증 처리
/api/member/refresh 경로 예외 처리
유효한 토큰을 가진 사용자만 통과
2. CustomSecurityConfig (2차 URL 레벨 보안)
URL 패턴별 접근 권한 설정
permitAll(): 로그인, 회원가입, 토큰 리프레시 등
authenticated(): 게시글 작성/수정/삭제, 댓글 등
hasAnyRole('ADMIN','MANAGER'): 관리자 API
3. @PreAuthorize (3차 메서드 레벨 보안)
통일된 패턴:

일반 기능: @PreAuthorize("hasAnyRole('USER','MANAGER','ADMIN')")

BoardController (게시글 작성/수정/삭제)
ReplyController (댓글 작성/수정/삭제)
FileController (파일 업로드)
MemberController (마이페이지)
SocialController (마이페이지 수정)
관리자 기능: @PreAuthorize("hasAnyRole('ADMIN','MANAGER')")

AdminController 대부분 메서드
최고 관리자 전용: @PreAuthorize("hasRole('ADMIN')")

AdminController의 권한 변경 메서드
4. 프론트엔드 라우트 보호
ProtectedLogin: 로그인 필요한 페이지 보호
ProtectedAdmin: 관리자 권한 필요한 페이지 보호
BoardPr

